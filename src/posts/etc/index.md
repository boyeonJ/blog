---
date: '2025-10-03'
title: '기술은 문제에서 태어난다: 모듈과 번들러의 역사'
categories: ['Tools']
summary: '모듈 시스템과 번들러가 어떻게 발전해왔는지 흐름을 따라갑니다.'
pinned: true
---

단순히 코드를 작성하다가 문득, 당연하게 사용해왔던 Webpack과 같은 번들러, 그리고 모듈 시스템의 역사가 궁금해졌습니다. 이들이 어떤 문제를 해결하기 위해 등장했는지, 기술 발전의 흐름을 정리해보았습니다.

---

## Script 태그 시절

웹 초창기에는 단순히 <script src="a.js"></script>를 여러 개 나열하는 방식이 일반적이었습니다.

* 순서가 꼬이면 에러 발생 (예: a.js에서 정의한 함수를 b.js에서 먼저 호출)
* 전역 변수 충돌 (모든 JS가 window에 올라옴)
* 파일 수가 많아지면 HTTP/1.1 요청이 폭증 → 로딩 속도 저하

규모가 커질수록 유지 관리가 사실상 불가능해졌습니다.

---

## 모듈 시스템의 등장

이런 문제를 해결하기 위해 **모듈 시스템**이 등장했습니다. 처음에는 라이브러리 형태로 제안되었고, 이후 표준에 포함되었습니다.

* CommonJS (2009, Node.js)

  ```js
  const lib = require('lib');
  ```

  동기 로딩 기반. Node.js는 로컬 디스크에서 읽으므로 빠르지만, 브라우저에서는 네트워크 요청 때문에 비효율적이었습니다. 또한 런타임에 모듈이 결정되므로 트리 쉐이킹 같은 최적화가 불가능했습니다.

* AMD (2009, RequireJS)

  ```js
  define(['dep'], function(dep) { ... });
  ```

  브라우저 전용 비동기 로딩 방식을 지원했지만 문법이 장황하고 사용성이 좋지 않았습니다.

* ESM (2015, ES6)

  ```js
  import lib from './lib.js';
  ```

  파일 최상단에 import/export가 강제되며 정적 분석이 가능해졌습니다.
  → 빌드 시점에 어떤 모듈이 필요한지 알 수 있어 Tree-shaking, Code splitting 같은 최적화가 가능해졌습니다.

---

## 번들러의 필요성

브라우저가 ESM을 본격적으로 지원하기 전까지는 여전히 여러 스크립트를 하나로 묶어 제공해야 했습니다. 이 과정에서 **번들러**가 등장했습니다.

### 번들러가 등장한 배경

1. 호환성 문제: 브라우저는 ESM을 늦게 지원했기 때문에, 모듈 문법을 그대로 쓸 수 없었습니다. → 미리 변환해야 했습니다.
2. 성능 최적화: 파일이 늘어나면 네트워크 요청 수가 많아졌고, HTTP/1.1 환경에서는 병렬 요청 개수가 제한적이었습니다. → 여러 파일을 하나로 합쳐야 했습니다.
3. 자산 관리: JS뿐 아니라 CSS, 이미지, 폰트 등도 프로젝트 구성 요소가 되었는데, 이들을 체계적으로 불러오려면 통합된 관리 방식이 필요했습니다.

즉, 번들러란?
의존성 그래프를 기반으로 모듈을 하나(혹은 여러 개)로 묶고, 최적화하여 브라우저에서 실행 가능하게 만드는 도구입니다.

---

## Webpack

Webpack이 등장했을 당시(2014~2016년 즈음)에는 다른 번들러도 존재하긴 했습니다.

* Browserify (2011): CommonJS 모듈을 브라우저에서도 사용할 수 있게 해주는 도구. 하지만 JS만 다루고, CSS나 이미지 같은 자산은 지원하지 않았습니다.
* RequireJS (2009): AMD 기반 모듈 로더. 번들링보다는 런타임 로딩 중심이었기 때문에 한계가 있었습니다.

이런 상황에서 Webpack은 JS 외에도 CSS, 이미지, JSON 같은 다양한 자산을 모듈처럼 다루고, 빌드 시점에 최적화까지 지원했기 때문에 큰 주목을 받았습니다.

특히 SPA(싱글 페이지 애플리케이션)가 본격적으로 확산되던 시기라, React, Angular, Vue 같은 프레임워크와 결합하기에 최적이었고(SPA 프레임워크가 요구하는 트랜스파일·자산 통합·코드 스플리팅·HMR·캐싱 전략 같은 요소를 Webpack은 단일 파이프라인으로 모두 해결), 그 결과 Webpack은 사실상 표준처럼 자리잡게 되었습니다.

---

## Webpack의 역사

### v1 (2014~2016)

* Loader 체계 도입 (file-loader, css-loader 등)
* CommonsChunkPlugin → 공통 코드 분리
* 캐싱 해시 ([hash], [chunkhash])
* 코드 스플리팅, HMR(핫 리로드) 정착

### v2~v3 (2017)

* ESM 지원
* Dynamic import → 코드 스플리팅 표준화
* 청크 네이밍 주석 (/* webpackChunkName: "charts" */)
* Tree-shaking 도입 (정적 분석 기반)
* ModuleConcatenationPlugin(스코프 호이스팅) → 실행/파싱 비용 절감

### v4 (2018)

* mode 옵션 (production, development) 도입 → 최적화 기본값 자동화
* SplitChunksPlugin → vendor/공통 청크 분리 표준화
* mini-css-extract-plugin → CSS를 별도 파일로 추출, [contenthash] 기반 장기 캐싱 강화
* TerserPlugin → JS 압축 기본화(Uglify 대체)
* Prefetch/Preload magic comments → 네트워크 힌트 제공

### v5 (2020~현재)

* Asset Modules → file/url-loader 대체 (인라인 vs 파일 자동 분리)
* Deterministic IDs & real [contenthash] → 장기 캐싱 품질 개선
* Persistent caching (파일시스템 캐시) → 리빌드 속도 대폭 향상
* Tree-shaking 고도화 (sideEffects 플래그 활용)
* Module Federation → 마이크로 프론트엔드 런타임 통합
* Node polyfill 자동 제거 → 브라우저 번들 크기 감소
* css-minimizer-webpack-plugin → CSS 최적화 표준화

---

## Vite의 등장

Webpack은 강력했지만 무겁고 설정이 복잡했습니다.
→ Vite는 새로운 접근을 택했습니다.

* ESM 기반 Dev Server: 개발 중에는 번들 없이 브라우저가 모듈을 직접 로드
* On-demand Transform: 브라우저가 요청한 모듈만 TS/JSX 변환 → 시작 속도 빠름
* 프로덕션 빌드: Rollup 기반 빌드 → 트리 쉐이킹 및 코드 분할 최적화

---

## 마무리

지금까지 모듈과 번들러의 역사, 그리고 Webpack과 Vite의 흐름을 살펴보았습니다.

저는 단순히 “가장 많이 쓰이고 최신이니까 쓴다”라는 접근을 좋아하지 않습니다.
기술은 언제나 어떤 문제를 해결하기 위해 등장했는가에서 출발합니다.
이 과정을 따라가다 보면 현재 기술의 위치를 이해할 수 있고, 새로운 기술이 등장했을 때도 평가 기준이 생깁니다.

따라서 역사를 공부하는 일은 단순한 회고가 아니라, 앞으로의 선택과 기술적 시야를 넓히는 데 중요한 과정이라고 생각합니다.

---