---
date: '2025-10-05'
title: 'Rust'
categories: ['JavaScript', 'Tooling']
summary: 'Rust'
pinned: true
---

## Rust

Rust는 단독으로도 많이 쓰이는데 다른 언어랑 붙여서 성능/안전성 보강용으로 많이 쓰인다.

javascript에서 
브라우저: webassembly wasm-pack wasm-bindgen -> 브라우저에서 이미지 처리·파싱·수치연산 가속
node.js 애드온 -> 이미지/압축/암호화 같은 CPU 바운드 작업
데스크톱 앱: tauri -> 가벼운 데스크톱 툴(스크린샷 정리, Markdown 뷰어 등)

## 크레이트

* 러스트의 컴파일 단위이자 배포단위
* 컴파일 하면 하나의 실행 파일(바이너리 크레이트) 혹의 하나의 라이브러리(.wasm) 크레이트가 만들어짐
* crates.io는 Npm처럼 공개 크레이트를 올리고 받는 레지스트리
* 아하 한마디로 라이브러리 느낌인건가바

## 더 좋은 이유
* 연산 성능/안정성: C/C++/Rust가 LLVM을 거쳐 기계에 가까운 코드로 컴파일되고, 브라우저는 그 바이너리를 예측 가능하게 실행해. JIT 최적화가 풀리거나 히든클래스가 흔들리는 JS 특유의 성능 변동이 적음
* 대용량 배열 처리에 최적: 연속 메모리(Linear Memory)에서 TypedArray처럼 촘촘히 접근 → 루프/수치/이미지 처리에 강함. SIMD(벡터 명령), **멀티스레드(SharedArrayBuffer)**도 활용 가능(환경 지원 시).
* 언어/라이브러리 재사용: 기존 C/C++/Rust 라이브러리를 그대로 웹으로 포팅 가능(코덱, 압축, 수치연산 라이브러리 등).
* 메모리·타입 안전(Rust 기준): 버퍼 오버런, UAF 같은 메모리 버그 클래스 자체를 언어/타입 시스템으로 예방(보안·안정성↑).


# 언제 WASM가 이득이 큰가 (현실 체크리스트)
**다음 중 2~3개 이상이면 WASM 고려가 강추**:
1. **매 프레임 수십만~수천만 연산**을 한다
    * 예: 4K 이미지 필터, 컨볼루션/가우시안 블러, 포인트 클라우드/머신비전 전처리.
2. **큰 버퍼(≥ 1MB)나 긴 배열**을 자주 다룬다
    * 예: 오디오 FFT(1024~4096 윈도), 대형 CSV/바이너리 파싱, 비디오 프레임 변환.
3. **정밀/복잡 수치**가 필요하다
    * 예: 최적화/선형대수, 경로(베지어) 테셀레이션, 물리/시뮬레이션.
4. **알고리즘을 서버/데스크톱과 공유**하고 싶다
    * 하나의 코어(C++/Rust)를 웹으로 가져와 **동일한 결과**를 내야 하는 경우.
5. **보안/표준화된 구현**이 중요하다
    * 예: 암호화, 포맷 파서, sanitize 코어.
> 네가 방금 관심 보였던 **FFT 비주얼라이저**, **이미지 필터**는 전형적인 WASM 우량 사례야.

# 언제 JS/TS가 더 낫나 (굳이 WASM 안 씀)
* **DOM/스타일/레이아웃**이 병목일 때
    * 카드 기울이기, 버튼 인터랙션, 간단 수학 몇 번 → **JS가 최적**. 연산이 아니라 **레이아웃/페인트/합성**이 핵심.
* **연산량이 O(1)~O(수천)** 수준일 때
    * 센서 각도 → `rotateX/rotateY` 같은 건 JS로도 **0.1ms 미만**.
* **브리지 오버헤드가 더 클 때**
    * JS↔WASM를 자주 왕복하거나, 작은 작업을 **자잘하게** 많이 호출하면 손해.
* **네트워크/디스크가 병목**
    * CPU가 한가하면 WASM 이득이 거의 없음.

# 간단한 의사결정 트리
* “이거 **픽셀/샘플/행렬**을 **수십만 개**씩 다룬다?” → **WASM + 워커**로 오프로딩 ✅
* “**프레임당 4ms** 이상 CPU를 잡아먹는 루틴이 있다?” → WASM 고려 ✅
* “결과는 DOM 업데이트가 대부분?” → JS 유지, **업데이트 횟수/방식 최적화**가 먼저 ✅
* “작업이 아주 자잘해서 함수 호출을 수백/수천 번 해야 한다?” →
    * **배치 호출**(큰 버퍼 한 번에), **공유 메모리**/고정 버퍼 재사용을 설계할 수 있으면 WASM 여지 있음.
    * 못 하면 JS로 두는 게 낫다.

# WASM 쓸 때의 설계 팁(중요)
* **Web Worker**에서 WASM 실행 → 메인 스레드는 UI만 담당 (렌더 끊김 방지)
* **배치 처리**: 작은 호출 많이 하지 말고 **큰 버퍼**로 한 번에
* **메모리 재사용**: 매 프레임 `new Uint8Array/Float32Array` 만들지 말고, **고정 버퍼**로 돌려쓰기
* **SIMD/스레드**: 가능하면 `simd128`, `Atomics` + `SharedArrayBuffer`(보안 헤더 충족 시)로 더 가속
* **폴백**: 기능 지원 안 되는 브라우저는 JS 경로(또는 AnalyserNode 등)로 폴백

# 예로 드는 매칭표 
| 기능 아이디어                         | 권장 경로                     | 비고                     |
| ------------------------------- | ------------------------- | ---------------------- |
| 3D 카드 틸트/패럴랙스                   | **JS**                    | O(1) 연산 + DOM 합성 병목    |
| 실시간 오디오 스펙트럼(FFT)               | **WASM(+Worklet/Worker)** | N log N + 후처리, 안정적 FPS |
| 이미지 필터/리사이즈(대형)                 | **WASM**                  | 픽셀 루프, SIMD 가속 여지      |
| Markdown→HTML + sanitize(대량 문서) | **WASM(또는 서버 Rust)**      | 파싱/정규화 일관성과 성능         |
| 암호화/해시(대용량)                     | **WASM**                  | WebCrypto에 없는 알고리즘도 가능 |
| 데이터 집계(대형 CSV/로그)               | **WASM 또는 서버 Rust**       | 스트리밍 파싱 + 통계 루프        |

---