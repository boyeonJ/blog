---
date: '2025-09-28'
title: '프레임 드랍'
categories: ['Browser', 'Optimization']
summary: '프레임 드랍이 무엇인지 정의하고 주로 발생하는 원인에 대해 알아보기.'
---

## 프레임 드랍이란?

디스플레이가 60Hz라면 **한 프레임을 그릴 수 있는 시간은 16.7ms**, 120Hz면 **8.33ms**입니다. 이 시간 안에 아래 파이프라인이 모두 끝나야 합니다.

> JS 실행 → 스타일 계산 → 레이아웃(리플로우) → 페인트 → 합성(컴포지팅)

이 예산을 넘기면 해당 프레임을 놓치고, 스크롤/애니메이션이 **버벅임(jank)** 으로 보입니다. 이런 현상을 프레임 드랍이 발생한다라고 표현합니다.

```rust
|<---- 16.7ms ---->|<---- 16.7ms ---->|<---- 16.7ms ---->|
vsync──────────────vsync──────────────vsync──────────────
                   ↑ 여기까지 새 프레임 준비 못하면 → 이전 프레임 재사용
```


---

## 이벤트 루프 & 한 틱(tick)의 구조와 프레임 드랍

한 “틱”은 보통 다음 순서로 진행됩니다.

1. 매크로태스크 1개 실행  
   (예: 클릭 핸들러, setTimeout 콜백, MessageChannel 콜백)
2. 마이크로태스크 전부 비움  
   (예: Promise.then, queueMicrotask, MutationObserver)
3. 렌더 기회  
   (스타일/레이아웃/페인트/합성)
4. 다음 틱…

- 매크로태스크는 한 번에 1개만 실행 (렌더 기회를 보장하려는 설계)
- 마이크로태스크는 그 틱에서 전부 비움 → 여기서 작업을 과도하게 예약하면 렌더 전에 프레임 예산을 태워버릴 위험 (= 렌더 기아) →  프레임 드랍이 발생할 가능성 높아짐

---

## 프레임 드랍의 흔한 원인

### 1. 롱 태스크(Long Task) — JS가 예산을 독식
- 무거운 계산, 큰 JSON 파싱/직렬화, 거대 배열 정렬/필터
- 마이크로태스크 연쇄 (Promise.then/queueMicrotask)로 렌더 기회가 뒤로 밀림

### 2. 레이아웃 스래싱(Layout Thrashing)
- 읽기(측정: offsetWidth, getBoundingClientRect)와  
- 쓰기(스타일 변경)를 교차 실행 → **강제 동기 레이아웃** 반복

### 3. 페인트/합성 비용 폭증
- 큰 영역 리페인트, 큰 블러/복잡한 그림자/필터 남용
- 레이어 승격 실패로 합성 경로 비효율

### 4. 이미지/폰트 파이프라인
- 거대 이미지 즉시 디코딩, 스크롤 중 리사이즈/디코드
- 웹폰트 지연으로 레이아웃 흔들림(FOIT/FOUT)

### 5. GC(가비지 컬렉션) 일시 중지
- 단기/대량 객체 생성-폐기 패턴, 대형 구조체로 마킹/스윕 부담

---